//-----------------------------------------------------------------------
// Empty AVL exception

class EmptyAVLE extends Exception {
}

//-----------------------------------------------------------------------
// Abstract AVL class

abstract class AVL<E extends Comparable<E>> implements TreePrinter.PrintableNode {

    //--------------------------
    // Static fields and methods
    //--------------------------

    static EmptyAVLE EAVLX = new EmptyAVLE();

    //--------------------------
    // Getters and simple methods
    //--------------------------

    abstract E AVLData() throws EmptyAVLE;

    abstract AVL<E> AVLLeft() throws EmptyAVLE;

    abstract AVL<E> AVLRight() throws EmptyAVLE;

    abstract boolean isEmpty();

    abstract int AVLHeight();

    //--------------------------
    // Main methods
    //--------------------------

    abstract boolean AVLfind(E key);

    abstract AVL<E> AVLinsert(E key);

    abstract AVL<E> AVLeasyRight();

    abstract AVL<E> AVLrotateRight();

    abstract AVL<E> AVLeasyLeft();

    abstract AVL<E> AVLrotateLeft();

    /**
     * Four new methods to convert an AVL tree to a red-black one. The
     * main idea of the algorithm we will use can be captured by the
     * following invariants:
     *
     * An AVL tree of height 2n can be converted to a red tree
     *   with black height n. This is what method colorRed() should do.
     *
     * An AVL tree of height 2n can be converted to a black tree
     *   with black height (n+1). This is what method colorBlackEven
     *   should do.
     *
     * An AVL tree of height 2n+1 can be converted to a black tree
     *   with black height (n+1). This is what method colorBlackOdd
     *   should do.
     *
     * The entry point for these methods is the method toRB(). Simce
     * the root should be colored black, it calls colorBlackEven or
     * colorBlackOdd depending on whether the current AVL tree has
     * even height or odd height.
     *
     */

    abstract RedBlackT<E> toRB ();

    /**
     * When this method is called, it creates a black node whose
     * colors are calculated as follows:
     *   - if the current AVL tree has children of equal height,
     *     then the generated nodes are red
     *   - if the current AVL tree has children that differ in
     *     height, then the generated node for the shorter tree
     *     is black and the other is red
     */
    abstract RedBlackT<E> colorBlackOdd ();

    /**
     * When this method is called, it creates a black node whose children
     * will also be black. The children are generated by either colorBlackEven
     * or colorBlackOdd depending on whether the height of the AVL child
     * is even or odd.
     */
    abstract RedBlackT<E> colorBlackEven ();

    /**
     * When this method is called, it creates a red node whose children
     * must be black. The children are generated by either colorBlackEven
     * or colorBlackOdd depending on whether the height of the AVL child
     * is even or odd.
     */
    abstract RedBlackT<E> colorRed  ();
}

//-----------------------------------------------------------------------

class EmptyAVL<E extends Comparable<E>> extends AVL<E> {

    //--------------------------
    // Getters and simple methods
    //--------------------------

    E AVLData() throws EmptyAVLE {
        throw EAVLX;
    }

    AVL<E> AVLLeft() throws EmptyAVLE {
        throw EAVLX;
    }

    AVL<E> AVLRight() throws EmptyAVLE {
        throw EAVLX;
    }

    boolean isEmpty() {
        return true;
    }

    // We are changing our convention for the height of an empty tree
    // This will make it easier to state the invariant needed to
    // convert to a red-black tree
    int AVLHeight() {
        return 1;
    }

    //--------------------------
    // Main methods
    // Adapting the methods from before to this generic class
    //--------------------------

    boolean AVLfind(E key) {
        return false;
    }

    AVL<E> AVLinsert(E key) {
        return new AVLNode<>(key, new EmptyAVL<>(), new EmptyAVL<>());
    }

    AVL<E> AVLeasyRight() {
        throw new Error("Internal bug: should never call easyRight on empty tree");
    }

    AVL<E> AVLrotateRight() {
        throw new Error("Internal bug: should never call rotateRight on empty tree");
    }

    AVL<E> AVLeasyLeft() {
        throw new Error("Internal bug: should never call easyLeft on empty tree");
    }

    AVL<E> AVLrotateLeft() {
        throw new Error("Internal bug: should never call rotateLeft on empty tree");
    }

    RedBlackT<E> toRB () {
        // TODO
        return new EmptyRB<E>();
    }

    RedBlackT<E> colorBlackEven () {
        // TODO
        return new EmptyRB<E>();
    }

    RedBlackT<E> colorBlackOdd () {
        // TODO
        return new EmptyRB<E>();
    }

    RedBlackT<E> colorRed  () {
        // TODO
        throw new Error("SIKEEEEEEEEEEEEE you shouldn't call colorRed on an eempty tree lmaoooooooo");
    }

    //--------------------------
    // Override
    //--------------------------

    public boolean equals(Object o) {
        return (o instanceof EmptyAVL);
    }

    //--------------------------
    // Printable interface
    //--------------------------

    public TreePrinter.PrintableNode getLeft() {
        return null;
    }

    public TreePrinter.PrintableNode getRight() {
        return null;
    }

    public String getText() {
        return "";
    }
}

//-----------------------------------------------------------------------

class AVLNode<E extends Comparable<E>> extends AVL<E> {
    private final E data;
    private final AVL<E> left;
    private final AVL<E> right;
    private final int height;

    AVLNode(E data, AVL<E> left, AVL<E> right) {
        this.data = data;
        this.left = left;
        this.right = right;
        this.height = 1 + Math.max(left.AVLHeight(), right.AVLHeight());
    }

    //--------------------------
    // Getters and simple methods
    //--------------------------

    E AVLData() {
        return data;
    }

    AVL<E> AVLLeft() {
        return left;
    }

    AVL<E> AVLRight() {
        return right;
    }

    boolean isEmpty() {
        return false;
    }

    int AVLHeight() {
        return height;
    }

    //--------------------------
    // Main methods
    // Adapt methods from before to this generic class
    //--------------------------

    boolean AVLfind(E key) {
        return key.compareTo(data) == 0 || left.AVLfind(key) || right.AVLfind(key);
    }

    AVL<E> AVLinsert(E key) {
        // binary insert
        // rebalance by comparing heights
        AVLNode<E> tree;
        if (key.compareTo(this.AVLData()) < 0) {
            AVL<E> left = this.AVLLeft().AVLinsert(key);
            tree = new AVLNode<>(this.AVLData(), left, this.AVLRight());
            if (left.AVLHeight() > this.right.AVLHeight() + 1) {
                return tree.AVLrotateRight();
            }
        } else {
            AVL<E> right = this.AVLRight().AVLinsert(key);
            tree = new AVLNode<>(this.AVLData(), this.AVLLeft(), right);
            if (right.AVLHeight() > this.left.AVLHeight() + 1) {
                return tree.AVLrotateLeft();
            }
        }
        return tree;
    }

    AVL<E> AVLeasyRight() {
        try{
            //this.height = 1 + Math.max(left.AVLHeight(), right.AVLHeight());
            return new AVLNode(this.AVLLeft().AVLData(),this.AVLLeft().AVLLeft(), new AVLNode(this.AVLData(), this.AVLLeft().AVLRight(), this.AVLRight()));
        } catch(EmptyAVLE e){
            return new EmptyAVL();
        }
    }

    AVL<E> AVLrotateRight() {
        try{
            // if left child height > right child height
            var p = this.AVLLeft();
            if(p.AVLLeft().AVLHeight() < p.AVLRight().AVLHeight()){
                p = p.AVLeasyLeft();
            }
            return new AVLNode(this.AVLData(), p, this.AVLRight()).AVLeasyRight();
        }catch(EmptyAVLE e) {
            return new EmptyAVL();
        }
    }

    AVL<E> AVLeasyLeft() {
        try{
            //this.height = 1 + Math.max(left.AVLHeight(), right.AVLHeight());
            return new AVLNode(this.AVLRight().AVLData(), new AVLNode(this.AVLData(), this.AVLLeft(), this.AVLRight().AVLLeft()), this.AVLRight().AVLRight());
        } catch(EmptyAVLE e){
            return new EmptyAVL();
        }
    }

    AVL<E> AVLrotateLeft() {
        try{
            // if left child height > right child height
            var p = this.AVLRight();
            if(p.AVLLeft().AVLHeight() > p.AVLRight().AVLHeight()){
                p = p.AVLeasyRight();
            }
            return new AVLNode(this.AVLData(), this.AVLLeft(), p).AVLeasyLeft();
        }catch(EmptyAVLE e) {
            return new EmptyAVL();
        }
    }

    RedBlackT<E> toRB () {
        // TODO
        // checks if height if even: callColorblackEven; odd: colorBlackOdd
        /**
         * When this method is called, it creates a black node whose
         * colors are calculated as follows:
         *   - if the current AVL tree has children of equal height,
         *     then the generated nodes are red
         *   - if the current AVL tree has children that differ in
         *     height, then the generated node for the shorter tree
         *     is black and the other is red
         */
        if(this.AVLHeight() % 2 == 0){
            return this.colorBlackEven();
        }else{
            return this.colorBlackOdd();
        }
    }

    RedBlackT<E> colorBlackEven() {
        //color the node black and the children black
        // if cases: heights = same [coloredBlackOdd on both left and right], left > right: colorBlackOdd & colorBlackEven
        // left < right: colorBlackEven & colorBlackOdd;
         // TODO
        RBNode<E> root;
        int rootheight = this.height;
        int leftheight = this.left.AVLHeight();
        int rightheight = this.right.AVLHeight();

        if(rootheight == 2){
            // it's a leaf :D
            root = new RBNode<>(data, Color.BLACK, new EmptyRB<>(), new EmptyRB<>());
            return root;
        }
        if(leftheight == rightheight){
            root = new RBNode<>(data, Color.BLACK, left.colorBlackOdd(), right.colorBlackOdd());
        }
        else if(leftheight > rightheight){
            root = new RBNode<>(data, Color.BLACK, left.colorBlackOdd(), right.colorBlackEven());
        }
        //else if(leftheight < rightheight){
        else{
            root = new RBNode<>(data, Color.BLACK, left.colorBlackEven(), right.colorBlackOdd());
        }
        return root;
    }

    RedBlackT<E> colorBlackOdd () {
        //color the node black and the children red unless one of the children is shorter, then it is colored black.
        // will create more black children or red children
        // if cases: height = same [colorRed], left < right: colorBlackOdd & colorRed, right < left: colorBlackOdd & colorRed
        // TODO
        RBNode<E> root;
        int rootheight = this.height;
        int leftheight = this.left.AVLHeight();
        int rightheight = this.right.AVLHeight();

        if(rootheight == 2){
            // it's a leaf :D
            root = new RBNode<>(data, Color.BLACK, new EmptyRB<>(), new EmptyRB<>());
            return root;
        }
        if(leftheight == rightheight){
            root = new RBNode<>(data, Color.BLACK, left.colorRed(), right.colorRed());
        }
        else if(leftheight > rightheight){
            root = new RBNode<>(data, Color.BLACK, left.colorRed(), right.colorBlackOdd());
        }
        //else if(leftheight < rightheight){
        else{
            root = new RBNode<>(data, Color.BLACK, left.colorBlackOdd(), right.colorRed());
        }
        return root;
    }

    RedBlackT<E> colorRed() {
        //color the node in red and color the children black.
        //height even
        // if cases: height = same [colorBlackOdd], left < right: colorBlackEven & colorBlackOdd
        // right < left: colorBlackEven & colorBlackOdd
        // TODO
        RBNode<E> root;
        int rootheight = this.height;
        int leftheight = this.left.AVLHeight();
        int rightheight = this.right.AVLHeight();

        if(rootheight == 2){
            // it's a leaf :D
            root = new RBNode<>(data, Color.RED, new EmptyRB<>(), new EmptyRB<>());
            return root;
        }
        if(leftheight == rightheight){
            root = new RBNode<>(data, Color.RED, left.colorBlackOdd(), right.colorBlackOdd());
        }
        else if(leftheight > rightheight){
            root = new RBNode<>(data, Color.RED, left.colorBlackOdd(), right.colorBlackEven());
        }
        //else if(leftheight < rightheight){
        else{
            root = new RBNode<>(data, Color.RED, left.colorBlackEven(), right.colorBlackOdd());
        }
        return root;
    }

    //--------------------------
    // Override
    //--------------------------

    public boolean equals(Object o) {
        if (o instanceof AVLNode) {
            AVLNode other = (AVLNode) o;
            return data == other.data && left.equals(other.left) && right.equals(other.right);
        }
        return false;
    }

    //--------------------------
    // Printable interface
    //--------------------------

    public TreePrinter.PrintableNode getLeft() {
        return left.isEmpty() ? null : left;
    }

    public TreePrinter.PrintableNode getRight() {
        return right.isEmpty() ? null : right;
    }

    public String getText() {
        return String.valueOf(data);
    }
}

//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
